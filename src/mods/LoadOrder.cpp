// include your mod header file
#include "LoadOrder.hpp"

static uintptr_t  jmp_return   { NULL };
static uintptr_t  jmp_return01 { NULL };
static uintptr_t  jmp_return02 { NULL };
static uintptr_t  jmp_return03 { NULL };
constexpr uintptr_t detour2_conditional = 0x8DF5C0;
static bool mod_enabled{ false };
//uintptr_t  ModLoadOrder::some_shared_ptr{ NULL };
static bool exists{false};
static bool ArcInit{false};
/*
This file has been generated by IDA.
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long
#define __cppobj  

struct MtPropertyList;
struct MtPropertyListVtbl;
struct MtObjectVtbl;
struct MtDTIVtbl;
struct MtUI;
struct MtProperty;
struct MtStream;
struct MtPropertyCustomPARAM;
struct MtPropertyCustomVtbl;


/* 10289 */
struct __cppobj SResourceTypeInfo : MtObject
{
    unsigned int m_attr;
    const char *m_ext;
    const MtDTI *mp_dti;
};

/* 8663 */
struct __cppobj MtPropertyCustom
{
    MtPropertyCustomVtbl *vfptr;
};

/* 10290 */
struct __cppobj SResourceProperty : MtPropertyCustom
{
};

/* 10291 */
struct __declspec(align(4)) SResourceLoadingInfo
{
    char path[64];
    unsigned int attr;
    bool active;
};

/* 10292 */
struct SResourceResourcework
{
    CResource *presource;
    unsigned int offset;
    unsigned int orgsize;
    unsigned int datasize;
    unsigned int readsize;
    unsigned __int32 threadid : 31;
    unsigned __int32 complete : 1;
};

/* 10293 */
struct __cppobj SResourceDecodework
{
    MtStream *pin;
    MtCriticalSection cs;
    CResource *parc;
    char *pbuf;
    unsigned int bufsize;
    unsigned int readpt;
    unsigned int writept;
    unsigned int rnum;
    unsigned int rrequest;
    unsigned int rcomplete;
    unsigned int cancel;
    unsigned int datasize;
    unsigned int orgsize;
    __int64 start_time;
    __int64 end_time;
    SResourceResourcework rwork[4096];
};

/* 10294 */
struct __cppobj SResourceRemoteInfo : MtObject
{
    MtString m_pc_name;
    MtString m_folder_name;
};

/* 10295 */
struct __cppobj __declspec(align(8)) SResource : CSystem
{
    SResourceTypeInfo m_type_info[256];
    unsigned int m_type_info_num;
    MtString m_root_directory;
    MtString m_resource_path;
    MtString m_native_path;
    MtString m_resource_folder;
    MtString m_native_folder;
    CResource *mp_table[8192];
    SResourceProperty m_resource_property;
    bool m_optimize_enable;
    bool m_build_complete;
    bool m_force_hdd_cache;
    bool m_force_back_ground;
    void *m_loader_thread_handle;
    unsigned int m_loader_thread_id;
    unsigned int m_async_priority;
    bool m_load_end;
    bool m_auto_update;
    bool m_cache_enable;
    CResource *mp_load_list[1024];
    unsigned int m_load_num;
    SResourceLoadingInfo m_loading_info;
    SResourceDecodework m_decode_work;
    unsigned int m_decode_thread_mask;
    SResourceRemoteInfo m_remote_info;
    unsigned int m_decode_thread_num;
    void *m_decode_thread[3];
    unsigned int m_decode_thread_id[3];
    void *m_decode_event[3];
    void *m_decode_sync[3];
};

/* 8665 */
struct MtPropertyCustomVtbl
{
    void *f1;
    void *f2;
    void *f3;
    void *f4;
    void *f5;
};

/* 8510 */
struct __cppobj MtStream : MtObject
{
};

/* 126 */
struct __cppobj MtUI
{
};

/* 127 */
struct __cppobj MtProperty
{
    const char *m_name;
    unsigned __int16 m_type;
    unsigned __int16 m_attr;
    MtObject *mp_owner;
    int u4;
    int u5;
    void* f1;
    void* f2;
    unsigned int m_index;
    MtProperty *mp_next;
    MtProperty *mp_prev;
};

/* 120 */
struct __cppobj MtPropertyList
{
    MtPropertyListVtbl *vfptr;
    MtProperty *mp_element;
};

/* 123 */
struct MtDTIVtbl
{
    void *f1;
    MtObject *f2;
};

/* 8664 */
struct MtPropertyCustomPARAM
{
    const char *name;
    const char *value;
};

/* 121 */
struct MtPropertyListVtbl
{
    void *f1;
};

SResource** s_devil4_resource_ptr = (SResource**)0xE552D0;

BOOL file_exists(LPCTSTR sz_path)
{
    DWORD dw_attrib = GetFileAttributes(sz_path);

    return (dw_attrib != INVALID_FILE_ATTRIBUTES && 
        !(dw_attrib & FILE_ATTRIBUTE_DIRECTORY));
}


void __stdcall really_unsafe_string_write(char* path) {
    if (strstr(path, "mod"))
    {
        __try {
           path[0] = 'x';
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            return;
        }
    }
}

// we'll try to break the string passed to specialized
// path lookup function in sResource and hope it works
void __stdcall wew(MtDTI* dti, char* path) {
    static SResource* s_devil4_resource = *s_devil4_resource_ptr;
    char buf[MAX_PATH];
    memset(buf, 0, sizeof(buf));
    exists = false;

    std::string extension;
    // dont wanna strcmp
    uint32_t type = *(uint32_t*)dti->m_name;
    char* name = dti->m_name;
    char key[3];
    memcpy(key,path,sizeof(key));
    switch (type) { // TODO(): more types? too much rWhatever classes ;_;
        case 0x646F4D72: extension = "mod"; break;
        case 0x74744172: extension = "atk"; break;
        case 0x6C6F4372:
            if (std::strstr(name,"rCollisionShape"))
                extension = "col";
            break;
        case 0x78655472: extension = "tex"; break;
        case 0x66664572: extension = "efl"; break;
        case 0x68635372: extension = "sdl"; break;
        case 0x746F4D72: extension = "lmt"; break;
        case 0x616C5072: extension = "pla"; break;
        case 0x72705372:
            if (std::strstr(name,"rSprLayout"))
                extension = "rSprLayout";
            else
                extension = "rSprAnm";
            break;
    }

    // GetFileAttributes needs a full path iirc, unfortunate
    sprintf_s(buf, "%s\\%s.%s", s_devil4_resource->m_native_path.value->str, path, extension.c_str());
    if (file_exists(buf)) 
    {
        if (!(strcmp(key,"sys")==0||strcmp(key,"mov")==0||strcmp(key,"rom")==0)||strcmp(key,"id\\"))
            if (ArcInit)
                exists=true;
        s_devil4_resource->m_optimize_enable = false;
        s_devil4_resource->m_build_complete = false;
        // really_unsafe_string_write(path);
    }
}

void __stdcall Filter(char* path) {
    if (std::strstr(path,"effect\\arc\\efc_cmn")||
    std::strstr(path,"rom\\system\\game_cmn")||
    std::strstr(path,"rom\\system\\dmc4_cmn")||
    std::strstr(path,"system\\shader")||
    std::strstr(path,"rom\\id\\nowloading"))
        ArcInit = false;
    else
        ArcInit = true;
}

// cResource* __userpurge sResource::create_sub_8DF530@<eax>(
// sResource* sDevil4Resource@<eax>, MtDTI* dti, const char* path,
// unsigned int mode)
naked void detour() {
    __asm {
        push ecx // original code
        push ebx
        push ebp
        push esi
        push edi
        pushad  // call our shitty hacks
        push eax // path is passed in eax
        mov ecx, [esp+0x3C] // dti is on the stack 
        push ecx
        call wew
        popad
        jmp dword ptr [jmp_return]
    }
#if 0
	__asm {
        push eax
        mov eax, [esp+0x0C]
        push eax
        call FileExists
        test al, al
        pop eax
        je originalCode

        int 3

    originalCode:
        mov esi, eax
        test esi, esi
        // je dword ptr [jmp_far]
        jmp dword ptr [jmp_return]
	}
#endif
}

naked void detour2()
{
    __asm{
        cmp byte ptr [mod_enabled], 1
        jne code

        cmp byte ptr [exists], 1
        jne code
        add dl, 0x01
        add cl, 0x01
    code:
        mov [esi+0x5C], edx
        and edi, 0x00070000
        jmp [jmp_return01]
    }
}
naked void detour3()
{
    __asm{
        cmp byte ptr [mod_enabled], 1
        jne originalcode

        pushad
        lea eax, [ebx+0x4]
        push eax
        call Filter
        popad
    originalcode:
        mov esi, [esp+0x14]
        add esi, 0x48
        jmp [jmp_return02]
    }
}

naked void detour4()
{
    __asm{
        mov byte ptr [ArcInit], 0
    // originalcode:
        test al, al
        mov [esp+0x13], al
        jmp [jmp_return03]
    }
}

std::optional<std::string> LoadOrder::on_initialize() {
    if (!install_hook_absolute(0x8DFCF0, m_hook, &detour, &jmp_return, 5))
    {
        spdlog::error("Failed to init LoadOrder mod\n");
        return "Failed to init LoadOrder mod";
    }
    if (!install_hook_absolute(0x8DF2C2, m_hook1, &detour2, &jmp_return01, 9))
    {
       spdlog::error("Failed to init LoadOrder mod\n");
       return "Failed to init LoadOrder mod";
    }
    if (!install_hook_offset(0x4E18F2, m_hook2, &detour3, &jmp_return02, 7))
     {
         spdlog::error("Failed to init LoadOrder mod\n");
         return "Failed to init LoadOrder mod";
     }
    if (!install_hook_offset(0x4E19A0, m_hook3, &detour4, &jmp_return03, 6))
    {
        spdlog::error("Failed to init LoadOrder mod\n");
        return "Failed to init LoadOrder mod";
    }
	return Mod::on_initialize();
}

// onFrame()
// do something each frame example
// void ModLoadOrder::onFrame(fmilliseconds& dt) {}

// onConfigSave
// save your data into cfg structure.
void LoadOrder::on_config_save(utility::Config& cfg) 
{ 
    cfg.set<bool>("LoadOrderHDD", mod_enabled); 
};

// onConfigLoad
// load data into variables from config structure.
void LoadOrder::on_config_load(const utility::Config& cfg) 
{ 
    mod_enabled = cfg.get<bool>("LoadOrderHDD").value_or(true);
};

// onGUIframe()
// draw your imgui widgets here, you are inside imgui context.
void LoadOrder::on_gui_frame() 
{ 
    ImGui::Checkbox(_("HDD File Priority"), &mod_enabled);
    ImGui::SameLine();
    help_marker(_("The game will look for files outside of arcs before looking inside"));
};

// onGamePause()
// do something when toggling a gui
// void ModName::onGamePause(bool toggle) { };

// onMessage()
// handle some window message, return true to pass to the game window
// or false to drop it.
// bool ModName::onMessage(HWND wnd, UINT message, WPARAM wParam, LPARAM lParam) { return true; };
