// include your mod header file
#include "LoadOrder.hpp"

static uintptr_t  jmp_return   { NULL };
static uintptr_t  jmp_return01 { NULL };

static bool mod_enabled{ false };
//uintptr_t  ModLoadOrder::some_shared_ptr{ NULL };

/*
This file has been generated by IDA.
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long
#define __cppobj  

struct MtPropertyList;
struct MtPropertyListVtbl;
struct MtObjectVtbl;
struct MtDTIVtbl;
struct MtUI;
struct MtProperty;
struct MtStream;
struct MtPropertyCustomPARAM;
struct MtPropertyCustomVtbl;


/* 10289 */
struct __cppobj SResourceTypeInfo : MtObject
{
    unsigned int m_attr;
    const char *m_ext;
    const MtDTI *mp_dti;
};

/* 8663 */
struct __cppobj MtPropertyCustom
{
    MtPropertyCustomVtbl *vfptr;
};

/* 10290 */
struct __cppobj SResourceProperty : MtPropertyCustom
{
};

/* 10291 */
struct __declspec(align(4)) SResourceLoadingInfo
{
    char path[64];
    unsigned int attr;
    bool active;
};

/* 10292 */
struct SResourceResourcework
{
    CResource *presource;
    unsigned int offset;
    unsigned int orgsize;
    unsigned int datasize;
    unsigned int readsize;
    unsigned __int32 threadid : 31;
    unsigned __int32 complete : 1;
};

/* 10293 */
struct __cppobj SResourceDecodework
{
    MtStream *pin;
    MtCriticalSection cs;
    CResource *parc;
    char *pbuf;
    unsigned int bufsize;
    unsigned int readpt;
    unsigned int writept;
    unsigned int rnum;
    unsigned int rrequest;
    unsigned int rcomplete;
    unsigned int cancel;
    unsigned int datasize;
    unsigned int orgsize;
    __int64 start_time;
    __int64 end_time;
    SResourceResourcework rwork[4096];
};

/* 10294 */
struct __cppobj SResourceRemoteInfo : MtObject
{
    MtString m_pc_name;
    MtString m_folder_name;
};

/* 10295 */
struct __cppobj __declspec(align(8)) SResource : CSystem
{
    SResourceTypeInfo m_type_info[256];
    unsigned int m_type_info_num;
    MtString m_root_directory;
    MtString m_resource_path;
    MtString m_native_path;
    MtString m_resource_folder;
    MtString m_native_folder;
    CResource *mp_table[8192];
    SResourceProperty m_resource_property;
    bool m_optimize_enable;
    bool m_build_complete;
    bool m_force_hdd_cache;
    bool m_force_back_ground;
    void *m_loader_thread_handle;
    unsigned int m_loader_thread_id;
    unsigned int m_async_priority;
    bool m_load_end;
    bool m_auto_update;
    bool m_cache_enable;
    CResource *mp_load_list[1024];
    unsigned int m_load_num;
    SResourceLoadingInfo m_loading_info;
    SResourceDecodework m_decode_work;
    unsigned int m_decode_thread_mask;
    SResourceRemoteInfo m_remote_info;
    unsigned int m_decode_thread_num;
    void *m_decode_thread[3];
    unsigned int m_decode_thread_id[3];
    void *m_decode_event[3];
    void *m_decode_sync[3];
};

/* 8665 */
struct MtPropertyCustomVtbl
{
    void *f1;
    void *f2;
    void *f3;
    void *f4;
    void *f5;
};

/* 8510 */
struct __cppobj MtStream : MtObject
{
};

/* 126 */
struct __cppobj MtUI
{
};

/* 127 */
struct __cppobj MtProperty
{
    const char *m_name;
    unsigned __int16 m_type;
    unsigned __int16 m_attr;
    MtObject *mp_owner;
    int u4;
    int u5;
    void* f1;
    void* f2;
    unsigned int m_index;
    MtProperty *mp_next;
    MtProperty *mp_prev;
};

/* 120 */
struct __cppobj MtPropertyList
{
    MtPropertyListVtbl *vfptr;
    MtProperty *mp_element;
};

/* 123 */
struct MtDTIVtbl
{
    void *f1;
    MtObject *f2;
};

/* 8664 */
struct MtPropertyCustomPARAM
{
    const char *name;
    const char *value;
};

/* 121 */
struct MtPropertyListVtbl
{
    void *f1;
};

SResource** s_devil4_resource_ptr = (SResource**)0xE552D0;

BOOL file_exists(LPCTSTR sz_path)
{
    DWORD dw_attrib = GetFileAttributes(sz_path);

    return (dw_attrib != INVALID_FILE_ATTRIBUTES && 
        !(dw_attrib & FILE_ATTRIBUTE_DIRECTORY));
}


void __stdcall really_unsafe_string_write(char* path) {
    if (strstr(path, "mod"))
    {
        __try {
            path[0] = 'x';
        }
        __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            return;
        }
    }
}

// we'll try to break the string passed to specialized
// path lookup function in sResource and hope it works
void __stdcall wew(MtDTI* dti, char* path) {
    static SResource* s_devil4_resource = *s_devil4_resource_ptr;
    char buf[MAX_PATH];
    memset(buf, 0, sizeof(buf));

    std::string extension;
    // dont wanna strcmp
    uint32_t type = *(uint32_t*)dti->m_name;
    
    switch (type) { // TODO(): more types? too much rWhatever classes ;_;
    case 0x646F4D72: extension = "mod"; break;
    case 0x78655472: extension = "tex"; break;
    }

    // GetFileAttributes needs a full path iirc, unfortunate
    sprintf_s(buf, "%s\\%s.%s", s_devil4_resource->m_resource_path.value->str, path, extension.c_str());
    if (file_exists(buf)) 
    {
        really_unsafe_string_write(path);
    }
}

//cResource* __userpurge sResource::create_sub_8DF530@<eax>(
// sResource* sDevil4Resource@<eax>, MtDTI* dti, const char* path,
// unsigned int mode)
naked void detour() {
    __asm {
        push ecx // original code
        push ebx
        push ebp
        push esi
        push edi
        pushad  // call our shitty hacks
        push eax // path is passed in eax
        mov ecx, [esp+3Ch] // dti is on the stack 
        push ecx
        call wew
        popad
        jmp dword ptr [jmp_return]
    }
#if 0
	__asm {
        push eax
        mov eax, [esp+0Ch]
        push eax
        call FileExists
        test al, al
        pop eax
        je originalCode

        int 3

    originalCode:
        mov esi, eax
        test esi, esi
        //je dword ptr [jmp_far]
        jmp dword ptr [jmp_return]
	}
#endif
}


void LoadOrder::toggle(bool enable) {
    if (enable) 
    {
        m_hook = std::make_unique<FunctionHook>(0x8DFCF0, detour);
        jmp_return = 0x8DFCF0 + 5;
    }
    else 
    {
        m_hook.reset();
    }
}

std::optional<std::string> LoadOrder::on_initialize() {
    /*if (!install_hook_absolute(0x8DFCF0, m_hook, &detour, &jmp_return, 5))
    {
        spdlog::error("Failed to init LoadOrder mod\n");
        return "Failed to init LoadOrder mod";
    }*/
	return Mod::on_initialize();
}

// onFrame()
// do something each frame example
//void ModLoadOrder::onFrame(fmilliseconds& dt) {}

// onConfigSave
// save your data into cfg structure.
void LoadOrder::on_config_save(utility::Config& cfg) 
{ 
    cfg.set<bool>("LoadOrderHDD", m_enabled); 
};

// onConfigLoad
// load data into variables from config structure.
void LoadOrder::on_config_load(const utility::Config& cfg) 
{ 
    m_enabled = cfg.get<bool>("LoadOrderHDD").value_or(false);
    toggle(m_enabled);
};

// onGUIframe()
// draw your imgui widgets here, you are inside imgui context.
void LoadOrder::on_gui_frame() 
{ 
    if (ImGui::Checkbox("WIP HDD file priority instead of .arc", &m_enabled))
    {
        toggle(m_enabled);
    }
};

// onGamePause()
// do something when toggling a gui
//void ModName::onGamePause(bool toggle) { };

// onMessage()
// handle some window message, return true to pass to the game window
// or false to drop it.
//bool ModName::onMessage(HWND wnd, UINT message, WPARAM wParam, LPARAM lParam) { return true; };

